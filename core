package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"github.com/andersfylling/disgord"
	"github.com/bwmarrin/discordgo" // Used for voice only due to its simplicity in this context

	"github.com/bwmarrin/dca" // DCA library for audio encoding
	"github.com/pkg/errors"
)

// A map to store the voice connection for each guild.
var voiceConnections = make(map[disgord.Snowflake]*discordgo.VoiceConnection)
var voiceConnectionMu sync.Mutex

// A simple map to track the audio player status for each guild.
var players = make(map[disgord.Snowflake]struct {
	ctx        context.Context
	cancel     context.CancelFunc
	isPlaying  bool
	isPaused   bool
	connection *discordgo.VoiceConnection
	encoder    *dca.EncodeSession
	stream     *dca.StreamingSession
})
var playersMu sync.Mutex

// The URL of the public radio station to stream.
// This is "Classic Rock Florida HD" from the Radio-Browser API.
const radioStreamURL = "http://radio.classic-rock.rocks:8000/stream"
const radioStationName = "Classic Rock Florida HD"

func main() {
	// 1. Get the bot token from environment variables.
	token := os.Getenv("DISCORD_BOT_TOKEN")
	if token == "" {
		log.Fatal("DISCORD_BOT_TOKEN environment variable not set.")
	}

	// 2. Create a new disgord client.
	client := disgord.New(disgord.Config{
		BotToken: token,
		Logger: disgord.Default ");
		
		// 3. Register the event handler for Ready event.
		client.Gateway().BotReady(func() {
			log.Println("Bot is ready!")
		})
	})
	
	// Register the slash command handler.
	client.Gateway().InteractionCreate(func(s disgord.Session, h *disgord.InteractionCreate) {
		interaction := h.Interaction
		if interaction.Type != disgord.InteractionTypeApplicationCommand {
			return
		}

		// 4. Handle the '/radio' slash command.
		cmd := interaction.Data.(disgord.ApplicationCommandInteractionData)
		if cmd.Name == "radio" {
			handleRadioCommand(s, interaction)
		}
	})

	// Register the component interaction handler for buttons.
	client.Gateway().InteractionCreate(func(s disgord.Session, h *disgord.InteractionCreate) {
		interaction := h.Interaction
		if interaction.Type != disgord.InteractionTypeMessageComponent {
			return
		}

		// 5. Handle button clicks.
		data := interaction.Data.(disgord.MessageComponentInteractionData)
		switch data.CustomID {
		case "pause":
			handlePauseButton(s, interaction)
		case "stop":
			handleStopButton(s, interaction)
		}
	})

	// 6. Set up a channel to listen for OS signals to gracefully shut down the bot.
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM, os.Interrupt)

	// 7. Start the bot.
	err := client.Gateway().Connect(context.Background())
	if err != nil {
		log.Fatal(errors.Wrap(err, "failed to connect to Discord"))
	}

	// Wait for an OS signal to stop the bot.
	<-stop

	log.Println("Shutting down...")
	client.Gateway().Disconnect()
}

// handleRadioCommand processes the /radio slash command.
func handleRadioCommand(s disgord.Session, interaction *disgord.Interaction) {
	// Reply to the interaction to prevent the "thinking" message.
	s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
		Type: disgord.InteractionResponseDeferredChannelMessageWithSource,
	})

	// Get the voice channel ID of the user who issued the command.
	guildID := interaction.GuildID
	voiceChannelID := interaction.Member.VoiceState.ChannelID

	if voiceChannelID == 0 {
		s.Followup(context.Background(), interaction.ApplicationID, interaction.Token, &disgord.CreateWebhookMessage{
			Content: "You need to be in a voice channel to use this command!",
			Flags: disgord.MessageFlagEphemeral,
		})
		return
	}

	// Join the voice channel.
	voiceConnectionMu.Lock()
	defer voiceConnectionMu.Unlock()
	
	dgSession, err := discordgo.New("Bot " + os.Getenv("DISCORD_BOT_TOKEN"))
	if err != nil {
		log.Println("Error creating discordgo session:", err)
		return
	}

	vc, err := dgSession.ChannelVoiceJoin(guildID.String(), voiceChannelID.String(), false, true)
	if err != nil {
		log.Println("Error joining voice channel:", err)
		s.Followup(context.Background(), interaction.ApplicationID, interaction.Token, &disgord.CreateWebhookMessage{
			Content: "Failed to join voice channel.",
			Flags: disgord.MessageFlagEphemeral,
		})
		return
	}
	voiceConnections[guildID] = vc

	// Start streaming the radio station.
	go func() {
		playersMu.Lock()
		defer playersMu.Unlock()

		// If a player is already running, stop it first.
		if _, ok := players[guildID]; ok {
			players[guildID].cancel()
			delete(players, guildID)
		}

		ctx, cancel := context.WithCancel(context.Background())

		// Create a DCA encoding session.
		options := dca.StdEncodeOptions
		options.RawOutput = true // Required for streaming
		encoder, err := dca.EncodeFile(radioStreamURL, options)
		if err != nil {
			log.Println("Error encoding:", err)
			cancel()
			return
		}

		players[guildID] = struct {
			ctx        context.Context
			cancel     context.CancelFunc
			isPlaying  bool
			isPaused   bool
			connection *discordgo.VoiceConnection
			encoder    *dca.EncodeSession
			stream     *dca.StreamingSession
		}{
			ctx:        ctx,
			cancel:     cancel,
			isPlaying:  true,
			connection: vc,
			encoder:    encoder,
		}

		// Create the audio streaming session and begin sending frames.
		done := make(chan error)
		stream := dca.NewStream(encoder, vc.OpusSend, done)
		players[guildID] = struct {
			ctx        context.Context
			cancel     context.CancelFunc
			isPlaying  bool
			isPaused   bool
			connection *discordgo.VoiceConnection
			encoder    *dca.EncodeSession
			stream     *dca.StreamingSession
		}{
			ctx:        ctx,
			cancel:     cancel,
			isPlaying:  true,
			connection: vc,
			encoder:    encoder,
			stream:     stream,
		}
		
		log.Println("Streaming started")

		select {
		case err := <-done:
			if err != nil {
				log.Println("Stream finished with error:", err)
			}
		case <-ctx.Done():
			log.Println("Streaming cancelled.")
		}
	}()

	// Create a media player interface with buttons.
	// You can use the buttons to pause, resume, and stop the playback.
	components := []disgord.MessageComponent{
		&disgord.Button{
			CustomID: "pause",
			Label:    "Play/Pause",
			Style:    disgord.ButtonStylePrimary,
			Emoji: &disgord.Emoji{
				Name: "⏸️",
			},
		},
		&disgord.Button{
			CustomID: "stop",
			Label:    "Stop",
			Style:    disgord.ButtonStyleDanger,
			Emoji: &disgord.Emoji{
				Name: "⏹️",
			},
		},
	}
	actionRow := disgord.ActionRow(components)

	// Send the message with the media player interface.
	s.Followup(context.Background(), interaction.ApplicationID, interaction.Token, &disgord.CreateWebhookMessage{
		Content: "🎶 Now Playing: **" + radioStationName + "** 🎶",
		Components: []*disgord.MessageComponent{
			&actionRow,
		},
	})
}

// handlePauseButton pauses or resumes the radio stream.
func handlePauseButton(s disgord.Session, interaction *disgord.Interaction) {
	playersMu.Lock()
	defer playersMu.Unlock()
	guildID := interaction.GuildID
	player, ok := players[guildID]
	if !ok {
		s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
			Type: disgord.InteractionResponseChannelMessageWithSource,
			Data: &disgord.InteractionApplicationCommandCallbackData{
				Content: "No radio station is currently playing.",
				Flags:   disgord.MessageFlagEphemeral,
			},
		})
		return
	}

	if player.isPaused {
		// Resume the audio stream.
		player.connection.Speaking(true)
		player.isPaused = false
		s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
			Type: disgord.InteractionResponseChannelMessageWithSource,
			Data: &disgord.InteractionApplicationCommandCallbackData{
				Content: "Radio stream resumed.",
			},
		})
	} else {
		// Pause the audio stream.
		player.connection.Speaking(false)
		player.isPaused = true
		s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
			Type: disgord.InteractionResponseChannelMessageWithSource,
			Data: &disgord.InteractionApplicationCommandCallbackData{
				Content: "Radio stream paused.",
			},
		})
	}
}

// handleStopButton stops the radio stream and disconnects the bot.
func handleStopButton(s disgord.Session, interaction *disgord.Interaction) {
	playersMu.Lock()
	defer playersMu.Unlock()
	guildID := interaction.GuildID

	player, ok := players[guildID]
	if !ok {
		s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
			Type: disgord.InteractionResponseChannelMessageWithSource,
			Data: &disgord.InteractionApplicationCommandCallbackData{
				Content: "No radio station is currently playing.",
				Flags:   disgord.MessageFlagEphemeral,
			},
		})
		return
	}

	// Stop the streaming and disconnect.
	player.cancel()
	delete(players, guildID)
	
	voiceConnectionMu.Lock()
	defer voiceConnectionMu.Unlock()
	
	voiceConnections[guildID].Disconnect()
	delete(voiceConnections, guildID)

	s.SendInteractionResponse(context.Background(), interaction, &disgord.InteractionResponse{
		Type: disgord.InteractionResponseChannelMessageWithSource,
		Data: &disgord.InteractionApplicationCommandCallbackData{
			Content: "Radio stream stopped and I have left the voice channel.",
		},
	})
}
